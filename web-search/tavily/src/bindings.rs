// Generated by `wit-bindgen` 0.41.0. DO NOT EDIT!
// Options used:
//   * runtime_path: "wit_bindgen_rt"
//   * with "golem:web-search/web-search@1.0.0" = "golem_web_search::golem::web_search::web_search"
//   * generate_unused_types
use golem_web_search::golem::web_search::web_search as __with_name0;
#[rustfmt::skip]
#[allow(dead_code, clippy::all)]
pub mod golem {
    pub mod web_search {
        #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
        pub mod types {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() = super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            /// Optional image-related result data
            #[derive(Clone)]
            pub struct ImageResult {
                pub url: _rt::String,
                pub description: Option<_rt::String>,
            }
            impl ::core::fmt::Debug for ImageResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("ImageResult")
                        .field("url", &self.url)
                        .field("description", &self.description)
                        .finish()
                }
            }
            /// Core structure for a single search result
            #[derive(Clone)]
            pub struct SearchResult {
                pub title: _rt::String,
                pub url: _rt::String,
                pub snippet: _rt::String,
                pub display_url: Option<_rt::String>,
                pub source: Option<_rt::String>,
                pub score: Option<f64>,
                pub html_snippet: Option<_rt::String>,
                pub date_published: Option<_rt::String>,
                pub images: Option<_rt::Vec<ImageResult>>,
                pub content_chunks: Option<_rt::Vec<_rt::String>>,
            }
            impl ::core::fmt::Debug for SearchResult {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchResult")
                        .field("title", &self.title)
                        .field("url", &self.url)
                        .field("snippet", &self.snippet)
                        .field("display-url", &self.display_url)
                        .field("source", &self.source)
                        .field("score", &self.score)
                        .field("html-snippet", &self.html_snippet)
                        .field("date-published", &self.date_published)
                        .field("images", &self.images)
                        .field("content-chunks", &self.content_chunks)
                        .finish()
                }
            }
            /// Safe search settings
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum SafeSearchLevel {
                Off,
                Medium,
                High,
            }
            impl ::core::fmt::Debug for SafeSearchLevel {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SafeSearchLevel::Off => {
                            f.debug_tuple("SafeSearchLevel::Off").finish()
                        }
                        SafeSearchLevel::Medium => {
                            f.debug_tuple("SafeSearchLevel::Medium").finish()
                        }
                        SafeSearchLevel::High => {
                            f.debug_tuple("SafeSearchLevel::High").finish()
                        }
                    }
                }
            }
            impl SafeSearchLevel {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> SafeSearchLevel {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => SafeSearchLevel::Off,
                        1 => SafeSearchLevel::Medium,
                        2 => SafeSearchLevel::High,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Rate limiting metadata
            #[repr(C)]
            #[derive(Clone, Copy)]
            pub struct RateLimitInfo {
                pub limit: u32,
                pub remaining: u32,
                pub reset_timestamp: u64,
            }
            impl ::core::fmt::Debug for RateLimitInfo {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("RateLimitInfo")
                        .field("limit", &self.limit)
                        .field("remaining", &self.remaining)
                        .field("reset-timestamp", &self.reset_timestamp)
                        .finish()
                }
            }
            /// Optional metadata for a search session
            #[derive(Clone)]
            pub struct SearchMetadata {
                pub query: _rt::String,
                pub total_results: Option<u64>,
                pub search_time_ms: Option<f64>,
                pub safe_search: Option<SafeSearchLevel>,
                pub language: Option<_rt::String>,
                pub region: Option<_rt::String>,
                pub next_page_token: Option<_rt::String>,
                pub rate_limits: Option<RateLimitInfo>,
            }
            impl ::core::fmt::Debug for SearchMetadata {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchMetadata")
                        .field("query", &self.query)
                        .field("total-results", &self.total_results)
                        .field("search-time-ms", &self.search_time_ms)
                        .field("safe-search", &self.safe_search)
                        .field("language", &self.language)
                        .field("region", &self.region)
                        .field("next-page-token", &self.next_page_token)
                        .field("rate-limits", &self.rate_limits)
                        .finish()
                }
            }
            /// Supported time range filtering
            #[repr(u8)]
            #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
            pub enum TimeRange {
                Day,
                Week,
                Month,
                Year,
            }
            impl ::core::fmt::Debug for TimeRange {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        TimeRange::Day => f.debug_tuple("TimeRange::Day").finish(),
                        TimeRange::Week => f.debug_tuple("TimeRange::Week").finish(),
                        TimeRange::Month => f.debug_tuple("TimeRange::Month").finish(),
                        TimeRange::Year => f.debug_tuple("TimeRange::Year").finish(),
                    }
                }
            }
            impl TimeRange {
                #[doc(hidden)]
                pub unsafe fn _lift(val: u8) -> TimeRange {
                    if !cfg!(debug_assertions) {
                        return ::core::mem::transmute(val);
                    }
                    match val {
                        0 => TimeRange::Day,
                        1 => TimeRange::Week,
                        2 => TimeRange::Month,
                        3 => TimeRange::Year,
                        _ => panic!("invalid enum discriminant"),
                    }
                }
            }
            /// Query parameters accepted by the unified search API
            #[derive(Clone)]
            pub struct SearchParams {
                pub query: _rt::String,
                pub safe_search: Option<SafeSearchLevel>,
                pub language: Option<_rt::String>,
                pub region: Option<_rt::String>,
                pub max_results: Option<u32>,
                pub time_range: Option<TimeRange>,
                pub include_domains: Option<_rt::Vec<_rt::String>>,
                pub exclude_domains: Option<_rt::Vec<_rt::String>>,
                pub include_images: Option<bool>,
                pub include_html: Option<bool>,
                pub advanced_answer: Option<bool>,
            }
            impl ::core::fmt::Debug for SearchParams {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    f.debug_struct("SearchParams")
                        .field("query", &self.query)
                        .field("safe-search", &self.safe_search)
                        .field("language", &self.language)
                        .field("region", &self.region)
                        .field("max-results", &self.max_results)
                        .field("time-range", &self.time_range)
                        .field("include-domains", &self.include_domains)
                        .field("exclude-domains", &self.exclude_domains)
                        .field("include-images", &self.include_images)
                        .field("include-html", &self.include_html)
                        .field("advanced-answer", &self.advanced_answer)
                        .finish()
                }
            }
            /// Structured search error
            #[derive(Clone)]
            pub enum SearchError {
                InvalidQuery,
                RateLimited(u32),
                UnsupportedFeature(_rt::String),
                BackendError(_rt::String),
            }
            impl ::core::fmt::Debug for SearchError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    match self {
                        SearchError::InvalidQuery => {
                            f.debug_tuple("SearchError::InvalidQuery").finish()
                        }
                        SearchError::RateLimited(e) => {
                            f.debug_tuple("SearchError::RateLimited").field(e).finish()
                        }
                        SearchError::UnsupportedFeature(e) => {
                            f.debug_tuple("SearchError::UnsupportedFeature")
                                .field(e)
                                .finish()
                        }
                        SearchError::BackendError(e) => {
                            f.debug_tuple("SearchError::BackendError").field(e).finish()
                        }
                    }
                }
            }
            impl ::core::fmt::Display for SearchError {
                fn fmt(
                    &self,
                    f: &mut ::core::fmt::Formatter<'_>,
                ) -> ::core::fmt::Result {
                    write!(f, "{:?}", self)
                }
            }
            impl std::error::Error for SearchError {}
        }
    }
}
#[rustfmt::skip]
mod _rt {
    #![allow(dead_code, clippy::all)]
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    extern crate alloc as alloc_crate;
}
#[cfg(target_arch = "wasm32")]
#[unsafe(
    link_section = "component-type:wit-bindgen:0.41.0:golem:web-search-tavily@1.0.0:web-search-library:encoded world"
)]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1377] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xd8\x09\x01A\x02\x01\
A\x08\x01B\x1c\x01ks\x01r\x02\x03urls\x0bdescription\0\x04\0\x0cimage-result\x03\
\0\x01\x01ku\x01p\x02\x01k\x04\x01ps\x01k\x06\x01r\x0a\x05titles\x03urls\x07snip\
pets\x0bdisplay-url\0\x06source\0\x05score\x03\x0chtml-snippet\0\x0edate-publish\
ed\0\x06images\x05\x0econtent-chunks\x07\x04\0\x0dsearch-result\x03\0\x08\x01m\x03\
\x03off\x06medium\x04high\x04\0\x11safe-search-level\x03\0\x0a\x01r\x03\x05limit\
y\x09remainingy\x0freset-timestampw\x04\0\x0frate-limit-info\x03\0\x0c\x01kw\x01\
k\x0b\x01k\x0d\x01r\x08\x05querys\x0dtotal-results\x0e\x0esearch-time-ms\x03\x0b\
safe-search\x0f\x08language\0\x06region\0\x0fnext-page-token\0\x0brate-limits\x10\
\x04\0\x0fsearch-metadata\x03\0\x11\x01m\x04\x03day\x04week\x05month\x04year\x04\
\0\x0atime-range\x03\0\x13\x01ky\x01k\x14\x01k\x7f\x01r\x0b\x05querys\x0bsafe-se\
arch\x0f\x08language\0\x06region\0\x0bmax-results\x15\x0atime-range\x16\x0finclu\
de-domains\x07\x0fexclude-domains\x07\x0einclude-images\x17\x0cinclude-html\x17\x0f\
advanced-answer\x17\x04\0\x0dsearch-params\x03\0\x18\x01q\x04\x0dinvalid-query\0\
\0\x0crate-limited\x01y\0\x13unsupported-feature\x01s\0\x0dbackend-error\x01s\0\x04\
\0\x0csearch-error\x03\0\x1a\x03\0\x1cgolem:web-search/types@1.0.0\x05\0\x02\x03\
\0\0\x0dsearch-params\x02\x03\0\0\x0dsearch-result\x02\x03\0\0\x0fsearch-metadat\
a\x02\x03\0\0\x0csearch-error\x01B\x19\x02\x03\x02\x01\x01\x04\0\x0dsearch-param\
s\x03\0\0\x02\x03\x02\x01\x02\x04\0\x0dsearch-result\x03\0\x02\x02\x03\x02\x01\x03\
\x04\0\x0fsearch-metadata\x03\0\x04\x02\x03\x02\x01\x04\x04\0\x0csearch-error\x03\
\0\x06\x04\0\x0esearch-session\x03\x01\x01h\x08\x01j\x01\x03\x01\x07\x01@\x01\x04\
self\x09\0\x0a\x04\0\x20[method]search-session.next-page\x01\x0b\x01k\x05\x01@\x01\
\x04self\x09\0\x0c\x04\0#[method]search-session.get-metadata\x01\x0d\x01i\x08\x01\
j\x01\x0e\x01\x07\x01@\x01\x06params\x01\0\x0f\x04\0\x0cstart-search\x01\x10\x01\
p\x03\x01o\x02\x11\x0c\x01j\x01\x12\x01\x07\x01@\x01\x06params\x01\0\x13\x04\0\x0b\
search-once\x01\x14\x04\0!golem:web-search/web-search@1.0.0\x05\x05\x04\00golem:\
web-search-tavily/web-search-library@1.0.0\x04\0\x0b\x18\x01\0\x12web-search-lib\
rary\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\x070.227.1\
\x10wit-bindgen-rust\x060.41.0";
#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
